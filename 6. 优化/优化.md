上一节我们·解决了工程的开发调试问题，项目的生产和开发环境都已配置完成，并且约定了 Webpack 配置文件规范。但它还很粗糙，这一节我们就来一起打磨这套配置。

## 开发体验优化

#### 使用 ES6

ES6 不仅在原有对象上添加了一些常用方法，还新增了一些新的词法和语法给开发者带来了极大便利，它自然是不能缺席本项目的。但不同浏览器、不同版本对 ES6 的支持不一致，导致使用 ES6 是还存在些许阻碍，我们需要用 babel-loader 把 ES6 的词法和语法转换为 ES5。

前段时间刚介绍过 babel-loader / babel 7 ，这里就不再重复介绍，详情见 [babel-loader 使用指南](https://juejin.im/post/5ced3aa8f265da1b9612e4a7)

#### 热模块替换

在之前的配置中我们使用使用 `MiniCssExtractPlugin.loader` 来代替 `style-loader` ，因为我们需要把 CSS 从 JS 中分离出来。但 MiniCssExtractPlugin 目前还存在一个隐患，那就是它可能会影响到 hmr （热模块替换）功能，在它对 hmr 的支持前，我们只能在生产环境中使用它。

`webpack.base.conf.js`
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.styl(us)?$/,
        use: [
          process.env.NODE_ENV !== 'production' ?
          'vue-style-loader' : {
            loader: resolve('node_modules/mini-css-extract-plugin/dist/loader.js'),
            options: {
              publicPath: '../'
            }
          },
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2 // 在 css-loader 前执行的 loader 数量
            }
          },
          'postcss-loader',
          {
            loader: 'stylus-loader',
            options: {
              preferPathResolver: 'webpack' // 优先使用 webpack 用于路径解析，找不到再使用 stylus-loader 的路径解析
            }
          }
        ]
      }
    ]
  }
}
```

<font color=#999>实际上我上次使用它时看见有 hmr 配置项，就以为已经支持了，具体支持与否请看 [MiniCssExtractPlugin Docs]([MiniCssExtractPlugin](https://webpack.docschina.org/plugins/mini-css-extract-plugin/))</font>

当项目达到一定体量，打包速度、热加载性能优化的需求就会被提出来，毕竟谁也不愿意修改后花上十几秒甚至几分钟等待修改视图更新。接下里我会介绍一些通用的优化策略，但需要注意的是，最好的优化还是项目本身不能去踩一些无法优化的坑，已知两坑：超多页（ html-webpack-plugin 热更新时更新所有页面）和动态加载未指明明确路径（打包目录下所有页面）。

#### 提升构建速度：使用 DllPlugin & DllReferencePlugin 提前打包公共依赖

DllPlugin 和 DllReferencePlugin 绝对是优化打包速度的最佳利器，它可以把部分公共依赖提前打包好，在之后的打包中就不再打包这些依赖而是直接取用已经打包好的代码，通常情况能降低 20% ~ 50% 打包时间，当然它也有缺点：
- 需要在初始化和相关依赖更新时，额外执行一条命令
- 通常 dll 是在 `.html` 文件中引入，滥用会导致首屏加载变慢

但总归来说是利大于弊。
1. 新增 `webpack.dll.conf.js`
    ```javascript
    const webpack = require('webpack')
    const { CleanWebpackPlugin } = require('clean-webpack-plugin')
    const { resolve } = require('./utils')

    const libs = {
      _frame: ['vue', 'vue-router', 'vuex'],
      _utils: ['lodash']
    }

    module.exports = {
      mode: 'production',
      entry: { ...libs },
      performance: false,
      output: {
        path: resolve('dll'),
        filename: '[name].dll.js',
        library: '[name]' // 与 DllPlugin.name 保持一致
      },
      plugins: [
        new CleanWebpackPlugin({
          cleanOnceBeforeBuildPatterns: []
        }),
        new webpack.DllPlugin({
          name: '[name]',
          path: resolve('dll', '[name].manifest.json'),
          context: resolve('')
        })
      ]
    }
    ```

2. 在 `webpack.common.conf.js` 使用 DllReferencePlugin

   `webpack.common.conf.js`
   ```javascript
    const { generateDllReferences, generateAddAssests } = require('./utils')

    module.exports = {
      plugins: [
        ...generateAddAssests(),
        ...generateDllReferences()
      ]
    }
   ```

   ```bash
   # add-asset-html-webpack-plugin 用于把 dll 添加到 `index.html` 的 script 标签中
   # glob 支持正则匹配文件
   yarn add add-asset-html-webpack-plugin glob -D
   ```

   `utils.js`
   ```javascript
    const webpack = require('webpack')
    const glob = require('glob')
    const AddAssestHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')

    const generateDllReferences = function() {
      const manifests = glob.sync(`${resolve('dll')}/*.json`)

      return manifests.map(file => {
        return new webpack.DllReferencePlugin({
          // context: resolve(''),
          manifest: file
        })
      })
    }

    const generateAddAssests = function() {
      const dlls = glob.sync(`${resolve('dll')}/*.js`)

      return dlls.map(file => {
        return new AddAssestHtmlWebpackPlugin({
          filepath: file,
          outputPath: '/dll',
          publicPath: '/dll'
        })
      })
    }
   ```

3. 添加 npm scripts

   `package.json`
   ```json
    "scripts": {
      "dll": "webpack --config build/webpack.dll.conf.js"
    },
   ```

然后就可以用 `yarn dll` 打包配置好的全局公共依赖了，打包后会在 `src/dll` 目录生成 `*dll.js` 和 `*dll.json` ，前者是依赖经压缩合并后的文件（ `mode: production` ），后者是 `*dll.js` 文件和原始依赖的映射文件，用于被 DllReferencePlugin 解析建立引用和 `*dll.js` 之间的映射关系。

*构建中最耗时的两步是 babel 和压缩， babel 一般会配置忽略 `node_modules` 所以 DllPlugin 节约的是部分公共依赖的压缩时间，所以你如果不想用 DllPlugin 也可以在 `externals` 中将他们配置为外部依赖，用其他方式去压缩并引入他们*

#### 提升构建速度：生成合理的 Source Map
在 webpack 4 中，是否生成 Source Map 以及生成怎样的 Source Map 是由 `devtool` 配置控制的，选择合理的 Source Map 可以有效的缩短打包时间。在选择前我们还是应该明白，不设置 Source Map 时打包是最快的，之所以需要 Source Map ，是因为打包后的代码结构、文件名和打包前完全不一致，当存在报错时我们只能直接定位到打包后的某个文件，无法定位到源文件，极大程度增加了调试难度。而 Source Map 就是为了增强打包后代码的可调试性而存在的，所以我们在生产环境总是需要它，在开发环境则有更多选择。

`devtool` 可选配置有 `none` 、 `eval` 、 `cheap-eval-source-map` 等 13 种，各自功能和性能比较在 [文档](https://webpack.docschina.org/configuration/devtool/) 中有详细介绍。

配置项由一个或多个单词和连字符组成，每个单词都有其含义和性能损耗，每个配置项最终意义就由这些单词决定：
- `none` 不生成 Source Map ，性能 +++
- `eavl` 每个模块由 `eval` 执行，不能正确显示行数，不能用生产模式，性能 +++
- `module` 报错显示原始代码，性能 -
- `source` 报错显示行列信息，显示 babel 转译后代码，性能 --
- `cheap` 低开销模式，不映射列，性能 +
- `inline` 不生成单独的 Source Map 文件，性能 o

##### 开发环境
由于开发模式建议显示报错源码和行信息，所以 `module` 和 `source` 都是需要的，为了性能我们又需要 `eval` 和 `cheap` ，所以能参照配置项找到最适合开发环境的配置是 `devtool: cheap-module-eval-source-map` 。

##### 生产环境
生产环境由于几乎不存在调试需求（ JS 相关调试），所以我建议大家设置 `devtool: none` ，在需要调试的时候再更改设置为 `devtool: cheap-module-source-map` 。

#### 提升构建速度：

#### 使用 BundleAnalyzerPlugin 检查打包信息


## 用户体验优化

#### 压缩 CSS
Webpack 4 在 `production` 模式下是会默认压缩 JS 代码的，使用 [TerserWebpackPlugin](https://webpack.docschina.org/plugins/terser-webpack-plugin)，但 CSS 不会（ Webpack 5 会作为内置功能 ），所以我们需要 [OptimizeCSSAssetsPlugin](https://github.com/NMFR/optimize-css-assets-webpack-plugin) 的帮助。

##### 安装
```bash
yarn add optimize-css-assets-webpack-plugin -D
```

##### 使用
Webpack 插件使用大同小异，但在 Webpack 4 中使用这个插件需要特别注意，使用它时会重写 `optimization.minimizer` 选项，而压缩 JS 的插件 TerserWebpackPlugin 恰好就在这个选项的默认值中，重写会导致默认值失效，所以你还需要显式地声明 TerserWebpackPlugin 实例。

`webpack.prod.conf.js`
```javascript
const TerserJSPlugin = require("terser-webpack-plugin")
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin")

module.exports = {
  optimization: {
    minimizer: [
      new TerserJSPlugin({
        parallel: true // 开启多线程压缩
      }),
      new OptimizeCSSAssetsPlugin({})
    ]
  }
}

```

*压缩是生产环境下的优化，开发环境去设置它反而会影响到热加载性能、适得其反*

#### 代码分离

##### 分离前测试

我们先在项目中加上会被 home 和 page-a 公共引用的资源： `src/utils/index.js` & `src/styles/main.styl` ，然后再在两个页面分别引用他们，以 `page-a.vue` 举例。

`page-a.vue`
```vue
<template>
  <div class="page-a">
    <h1>
      This is page-a
    </h1>
  </div>
</template>

<script>
import { counter } from '@/utils'

export default {
  name: 'page-a',
  created() {
    counter()
    console.log('page-a:', counter.count)
  }
}
</script>

<style lang="stylus" scoped>
@import '~@/styles/main.styl';

.page-a {
  background: blue;
}
</style>

```

在命令行执行 `yarn build` 打包项目，然后我们就会在 `home.vue` 对应的生成物（ `dist/css/views/home.[contentHash].css` 和 `dist/views/home.[contentHash].js.` ）中看到，他们包含了  `src/styles/main.styl` 和 `src/utils/index.js`  文件中的所需内容。然而，我们再去检查 `page-a.vue` 对应的生成物，发现他们同样包含了这些内容，所以一份源码被打包到了两个页面对应的生成物中。

被重复打包是因为这两个页面同时引用了他们，当引用次数是 3 次、 10 次或者更多，这些公共资源（包括公共依赖）甚至可以占到生成物体积的 95% 以上，这显然是不可接受的。


##### SplitChunksPlugin

为了解决公共资源被重复打包问题，我们就需要 [SplitChunksPlugin](https://webpack.docschina.org/plugins/split-chunks-plugin/) 的帮助，它可以把代码分离成不同的 bundle ，在页面需要时被加载。另外 SplitChunksPlugin 是 webpack 4 的内置插件，所以我们不需要去独立安装它。

###### 配置
`webpack.prod.conf.js`
```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      minSize: 1, // 正常设置 20000+ 即 20k+ ，但这里我们的公共文件只有几行代码，所以设置为 1
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '/',
      name(mod, chunks) {
        return ${chunks[0].name}
      },
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
}
```

###### 更改输出命名

我们可以使用 VSCode 来调试打包配置代码（ nodejs ），得到 `name` 函数中的 `mod / chunks` 的对象结构，最终返回我们需要的生成物文件名。当然你也可以用 `-inspect` 来[调试](https://nodejs.org/zh-cn/docs/guides/debugging-getting-started/)代码。

```javascript
// 命名和代码分离息息相关，这里仅为使用示例，具体命名请根据项目情况更改
name(mod, chunks) {
  if (chunks[0].name === 'app') return 'app.vendor'

  if (/src/.test(mod.request)) {
    let requestName = mod.request.replace(/.*\\src\\/, '').replace(/"/g, '')
    if (requestName) return requestName
  } else if (/node_modules/.test(mod.request)) {
    return 'dependencies/' + mod.request.match(/node_modules.[\w-]+/)[0].replace(/node_modules./, '')
  }

  return null
}
```
*更多的情况是设置魔法注释来规定文件名，而不是通过 name 函数设置，因为后者往往会将一些不该分离的代码分离*

## 资源加载

#### 按需加载
按需加载又名懒加载，是指当需要依赖的页面被打开采取加载这个依赖，这样就减少了主页的负担，提升首屏渲染速度。而要做到按需加载，你只需在导入依赖的时候用 `import()` 或 `require.ensure` 这两种动态加载方式。我们添加 `lodash` 依赖来做测试： `yarn add lodash`

`page-a.vue`
```javascript
// 静态加载
import _ from 'lodash'
// 懒加载
// import(/* webpackChunkName: "dependencies/lodash" */ 'lodash')

export default {
  name: 'page-a',
  created() {
    console.log(_.now())
  }
}
```
此时启动一下开发服务，我们可以看到，虽然这里用了静态加载，但其实 lodash 依赖还是在点击进入了 page-a 才会被加载（懒加载）。因为我们在使用设置路由的时候，就已经使用过了 `import()` 动态加载（这一点我忘记了），所以 page-a 页面的静态资源也一起变作了懒加载。

我们再看一下之前的动态加载语句 `import(/* webpackChunkName: "views/home" */ '@/views/home/main.vue')` ，这其中有一个值得注意的知识点 `/* webpackChunkName: "views/home" */` ，它是 Webpack 的魔法注释，这里是通过魔法注释指定生成 chunk 的文件名，所以该 `src/views/home/main.vue` 文件打包后的 JS 就在 `dist/views/home.[contentHash].js`。

#### 预加载、预取
上面讲到使用魔法注释为生成物命名，其实预加载 preload 和预取 prefetch 也是通过魔法注释来设置的。这里是官方文档上有他们的异同介绍：

> - preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。
> - preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。

但在我的测试中，无论是 preload 还是 prefetch 都是并行加载的，但他们优先级会比当前页面所需依赖更低，不会影响到页面加载。你可以在 `main.js` 中添加以下代码进行测试：

`src/main.js`
```javascript
// 对比测试
// import 'lodash'
// 预加载
// import(/* webpackPreload: true, webpackChunkName: "dependencies/lodash" */ 'lodash')
// 预取
import(/* webpackPrefetch: true, webpackChunkName: "dependencies/lodash" */ 'lodash')
```

**本小节的测试结果由于和文档不符，希望大家自行验证，不可信我**

*用预加载和预取处理体积较大的依赖效果尤为明显，比如图表、富文本编辑器*




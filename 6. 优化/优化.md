上一节我们解决了工程的开发调试问题，项目的生产和开发环境都已配置完成，并且约定了 Webpack 配置文件规范。但它还很粗糙，这一节我们就来一起完成对这个项目的优化。

## 压缩 CSS
Webpack 4 在 `production` 模式下是会默认压缩 JS 代码的，使用 [TerserWebpackPlugin](https://webpack.docschina.org/plugins/terser-webpack-plugin)，但 CSS 并不会（ Webpack 5 会作为内置功能 ），所以我们需要 [OptimizeCSSAssetsPlugin](https://github.com/NMFR/optimize-css-assets-webpack-plugin) 的帮助。

#### 安装
```bash
yarn add optimize-css-assets-webpack-plugin -D
```

#### 使用
Webpack 插件使用大同小异，但在 Webpack 4 中使用这个插件需要特别注意，使用它时会重写 `optimization.minimizer` 选项，而压缩 JS 的插件 TerserWebpackPlugin 恰好就在这个选项的默认值中，重写会导致默认值失效，所以你还需要显式地声明 TerserWebpackPlugin 实例。

`webpack.prod.conf.js` <font color=#999>添加如下内容</font>
```javascript
const TerserJSPlugin = require("terser-webpack-plugin")
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin")

module.exports = {
  optimization: {
    minimizer: [
      new TerserJSPlugin({
        parallel: true // 开启多线程压缩
      }),
      new OptimizeCSSAssetsPlugin({})
    ]
  }
}

```

## 代码分离

#### 分离前测试

我们先在项目中加上会被 home 和 page-a 公共引用的资源： `src/utils/index.js` & `src/styles/main.styl` ，然后再在两个页面分别引用他们，以 `home.vue` 举例。

`home.vue`
```vue
<template>
  <div class="page-a">
    <h1>
      This is page-a
    </h1>
  </div>
</template>

<script>
import { counter } from '@/utils'

export default {
  name: 'page-a',
  created() {
    counter()
    console.log('home:', counter.count)
  }
}
</script>

<style lang="stylus" scoped>
@import '~@/styles/main.styl';

.page-a {
  background: blue;
}
</style>

```

在命令行执行 `yarn build` 打包项目，然后我们就会在 `home.vue` 对应的生成物（ `dist/css/views/home.[contentHash].css` 和 `dist/views/home.[contentHash].js.` ）中看到，他们包含了  `src/styles/main.styl` 和 `src/utils/index.js`  文件中的所需内容。然而，我们再去检查 `page-a.vue` 对应的生成物，发现他们同样包含了这些内容，所以一份源码被打包到了两个页面对应的生成物中。

被重复打包是因为这两个页面同时引用了他们，当引用次数是 3 次、 10 次或者更多，这些公共资源（包括公共依赖）甚至可以占到生成物体积的 95% 以上，这显然是不可接受的。

#### SplitChunksPlugin

为了解决公共资源被重复打包问题，我们就需要 [SplitChunksPlugin](https://webpack.docschina.org/plugins/split-chunks-plugin/) 的帮助，它可以把代码分离成不同的 bundle ，在页面需要时被加载。另外 SplitChunksPlugin 是 webpack 4 的内置插件，所以我们不需要去独立安装它。

##### 配置
`webpack.prod.conf.js`
```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      minSize: 1, // 正常设置 20000+ 即 20k+ ，但这里我们的公共文件只有几行代码，所以设置为 1
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: '/',
      name(mod, chunks) {
        return `${chunks[0].name}`
      },
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
        }
      }
    }
  }
}
```

##### 更改输出命名

我们可以使用 VSCode 来调试打包配置代码（ nodejs ），得到 `name` 函数中的 `mod / chunks` 的对象结构，最终返回我们需要的生成物文件名。当然你也可以用 `-inspect` 来[调试](https://nodejs.org/zh-cn/docs/guides/debugging-getting-started/)代码。

```javascript
name(mod, chunks) {
  if (chunks[0].name === 'app') return 'app.vendor'

  let requestName = mod.request.replace(/.*\\src\\/, '').replace(/"/g, '')
  if (requestName) return requestName

  return 'unname'
}
```

*CSS 压缩、代码分离都是生产环境下的优化，开发环境去设置他们反而会影响到热加载性能，其实在压缩、代码分离方面，生产环境和开发环境在优化上正好是对立的*
